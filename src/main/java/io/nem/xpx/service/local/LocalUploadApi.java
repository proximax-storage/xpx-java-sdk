/*
 * Proximax P2P Storage REST API
 * Proximax P2P Storage REST API
 *
 * OpenAPI spec version: v0.0.1
 * Contact: alvin.reyes@botmill.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.nem.xpx.service.local;

import com.google.flatbuffers.FlatBufferBuilder;
import io.ipfs.api.IPFS;
import io.ipfs.api.MerkleNode;
import io.ipfs.api.NamedStreamable;
import io.ipfs.multihash.Multihash;
import io.nem.xpx.exceptions.ApiException;
import io.nem.xpx.model.*;
import io.nem.xpx.service.intf.UploadApi;
import io.nem.xpx.service.model.buffers.ResourceHashMessage;
import io.nem.xpx.utils.ContentTypeUtils;
import io.nem.xpx.utils.JsonUtils;
import org.apache.commons.codec.binary.Base64;
import org.pmw.tinylog.Logger;

import java.io.File;
import java.io.IOException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;


/**
 * The Class LocalUploadApi.
 */
@SuppressWarnings("unchecked")

public class LocalUploadApi implements UploadApi {

	private final IPFS proximaxIfpsConnection;

	public LocalUploadApi(final IPFS proximaxIfpsConnection) {
		this.proximaxIfpsConnection = proximaxIfpsConnection;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * io.nem.xpx.service.intf.UploadApi#cleanupPinnedContentUsingPOST(java.lang.
	 * String)
	 */
	@Override
	public String cleanupPinnedContentUsingPOST(String multihash) throws ApiException, IOException {
		return proximaxIfpsConnection.pin.rm(Multihash.fromBase58(multihash)).toString();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * io.nem.xpx.service.intf.UploadApi#uploadBase64StringBinaryUsingPOST(io.nem.
	 * xpx.model.UploadBase64BinaryRequestParameter)
	 */
	@Override
	public Object uploadBase64StringBinaryUsingPOST(UploadBase64BinaryRequestParameter parameter)
			throws ApiException, IOException, NoSuchAlgorithmException {

		DataHashByteArrayEntity dataHashByteArrayEntity = new DataHashByteArrayEntity();
		dataHashByteArrayEntity.setFile(
				org.apache.commons.codec.binary.Base64.decodeBase64(parameter.getData().getBytes()));
		if (parameter.getName() == null || (parameter.getName() != null && parameter.getName().equals(""))) {
			dataHashByteArrayEntity.setName(Math.abs(System.currentTimeMillis()) + "");
		} else {
			dataHashByteArrayEntity.setName(parameter.getName());
		}

		dataHashByteArrayEntity.setContentType(ContentTypeUtils.contentTypeLookup(parameter.getContentType(), parameter.getData()));
		dataHashByteArrayEntity.setKeywords(parameter.getKeywords());
		dataHashByteArrayEntity.setMetadata(
				(parameter.getMetadata() == null) ? null : JsonUtils.fromJson(parameter.getMetadata(), Map.class));

		PublishResult spfsBlockResult = exposeAndPinBinary(dataHashByteArrayEntity.getName(),
				dataHashByteArrayEntity.getFile());
		String multiHashString = spfsBlockResult.getMerkleNode().get(0).hash.toBase58();

		FlatBufferBuilder builder = new FlatBufferBuilder(1024);

		MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");

		int digest = builder.createString(new String(
				org.bouncycastle.util.encoders.Hex.encode(messageDigest.digest(dataHashByteArrayEntity.getFile()))));

		int hash = builder.createString(multiHashString);
		int keywordsRes = builder.createString(
				(dataHashByteArrayEntity.getKeywords() == null) ? "" : dataHashByteArrayEntity.getKeywords());
		int metadataRes = builder.createString(JsonUtils
				.toJson((dataHashByteArrayEntity.getMetadata() == null) ? "" : dataHashByteArrayEntity.getMetadata()));
		int nameint = builder.createString(dataHashByteArrayEntity.getName());
		int type = builder.createString(dataHashByteArrayEntity.getContentType());

		ResourceHashMessage.startResourceHashMessage(builder);
		ResourceHashMessage.addDigest(builder, digest);
		ResourceHashMessage.addHash(builder, hash);
		ResourceHashMessage.addKeywords(builder, keywordsRes);
		ResourceHashMessage.addMetaData(builder, metadataRes);
		ResourceHashMessage.addName(builder, nameint);
		ResourceHashMessage.addTimestamp(builder, System.currentTimeMillis());
		ResourceHashMessage.addType(builder, type);
		builder.finish(ResourceHashMessage.endResourceHashMessage(builder));

		return Base64.encodeBase64(builder.sizedByteArray());
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * io.nem.xpx.service.intf.UploadApi#uploadBytesBinaryUsingPOST(io.nem.xpx.model
	 * .UploadBytesBinaryRequestParameter)
	 */
	@Override
	public Object uploadBytesBinaryUsingPOST(UploadBytesBinaryRequestParameter parameter)
			throws ApiException, IOException, NoSuchAlgorithmException {

		DataHashByteArrayEntity dataHashByteArrayEntity = new DataHashByteArrayEntity();
		dataHashByteArrayEntity.setFile(
				org.apache.commons.codec.binary.Base64.decodeBase64(parameter.getData()));
		if (parameter.getName() == null || (parameter.getName() != null && parameter.getName().equals(""))) {
			dataHashByteArrayEntity.setName(Math.abs(System.currentTimeMillis()) + "");
		} else {
			dataHashByteArrayEntity.setName(parameter.getName());
		}

		dataHashByteArrayEntity.setContentType(ContentTypeUtils.contentTypeLookup(parameter.getContentType(), parameter.getData()));
		dataHashByteArrayEntity.setKeywords(parameter.getKeywords());
		dataHashByteArrayEntity.setMetadata(
				(parameter.getMetadata() == null) ? null : JsonUtils.fromJson(parameter.getMetadata(), Map.class));

		PublishResult spfsBlockResult = exposeAndPinBinary(dataHashByteArrayEntity.getName(),
				dataHashByteArrayEntity.getFile());
		String multiHashString = spfsBlockResult.getMerkleNode().get(0).hash.toBase58();

		FlatBufferBuilder builder = new FlatBufferBuilder(1024);

		MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");

		int digest = builder.createString(new String(
				org.bouncycastle.util.encoders.Hex.encode(messageDigest.digest(dataHashByteArrayEntity.getFile()))));

		int hash = builder.createString(multiHashString);
		int keywordsRes = builder.createString(
				(dataHashByteArrayEntity.getKeywords() == null) ? "" : dataHashByteArrayEntity.getKeywords());
		int metadataRes = builder.createString(JsonUtils
				.toJson((dataHashByteArrayEntity.getMetadata() == null) ? "" : dataHashByteArrayEntity.getMetadata()));
		int nameint = builder.createString(dataHashByteArrayEntity.getName());
		int type = builder.createString(dataHashByteArrayEntity.getContentType());

		ResourceHashMessage.startResourceHashMessage(builder);
		ResourceHashMessage.addDigest(builder, digest);
		ResourceHashMessage.addHash(builder, hash);
		ResourceHashMessage.addKeywords(builder, keywordsRes);
		ResourceHashMessage.addMetaData(builder, metadataRes);
		ResourceHashMessage.addName(builder, nameint);
		ResourceHashMessage.addTimestamp(builder, System.currentTimeMillis());
		ResourceHashMessage.addType(builder, type);
		builder.finish(ResourceHashMessage.endResourceHashMessage(builder));

		return Base64.encodeBase64(builder.sizedByteArray());
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * io.nem.xpx.service.intf.UploadApi#uploadPlainTextUsingPOST(io.nem.xpx.model.
	 * UploadTextRequestParameter)
	 */
	@Override
	public Object uploadPlainTextUsingPOST(UploadTextRequestParameter parameter)
			throws ApiException, IOException, NoSuchAlgorithmException {

		// initialize the datahash byte array entity object.
		DataHashByteArrayEntity dataHashByteArrayEntity = new DataHashByteArrayEntity();
		String contentType = null;
		if (parameter.getEncoding() == null || parameter.getEncoding().equals("")) {
			parameter.setEncoding("UTF-8");
		}
		if (parameter.getContentType() == null
				|| (parameter.getContentType() != null && parameter.getContentType().equals(""))) {
			parameter.setContentType("text/plain");
		}
		dataHashByteArrayEntity.setFile(org.apache.commons.codec.binary.Base64.decodeBase64(parameter.getText()));
		if (parameter.getName() == null || (parameter.getName() != null && parameter.getName().equals(""))) {
			dataHashByteArrayEntity.setName(Math.abs(System.currentTimeMillis()) + "");
		} else {
			dataHashByteArrayEntity.setName(parameter.getName());
		}

		dataHashByteArrayEntity.setContentType(parameter.getContentType());
		dataHashByteArrayEntity.setKeywords(parameter.getKeywords());
		dataHashByteArrayEntity.setMetadata(
				(parameter.getMetadata() == null) ? null : JsonUtils.fromJson(parameter.getMetadata(), Map.class));

		// Expose/load the file.
		PublishResult spfsBlockResult = exposeAndPinBinary(dataHashByteArrayEntity.getName(),
				dataHashByteArrayEntity.getFile());

		String multiHashString = spfsBlockResult.getMerkleNode().get(0).hash.toBase58();

		// Serialize
		FlatBufferBuilder builder = new FlatBufferBuilder(1024);
		MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");

		int digest = builder.createString(new String(
				org.bouncycastle.util.encoders.Hex.encode(messageDigest.digest(dataHashByteArrayEntity.getFile()))));

		int hash = builder.createString(multiHashString);
		int keywordsRes = builder.createString(
				(dataHashByteArrayEntity.getKeywords() == null) ? "" : dataHashByteArrayEntity.getKeywords());
		int metadataRes = builder.createString(JsonUtils
				.toJson((dataHashByteArrayEntity.getMetadata() == null) ? "" : dataHashByteArrayEntity.getMetadata()));
		int nameint = builder.createString(dataHashByteArrayEntity.getName());
		int type = builder.createString(dataHashByteArrayEntity.getContentType());

		ResourceHashMessage.startResourceHashMessage(builder);
		ResourceHashMessage.addDigest(builder, digest);
		ResourceHashMessage.addHash(builder, hash);
		ResourceHashMessage.addKeywords(builder, keywordsRes);
		ResourceHashMessage.addMetaData(builder, metadataRes);
		ResourceHashMessage.addName(builder, nameint);
		ResourceHashMessage.addTimestamp(builder, System.currentTimeMillis());
		ResourceHashMessage.addType(builder, type);
		builder.finish(ResourceHashMessage.endResourceHashMessage(builder));

		// return base64 encoded bytearray.
		return Base64.encodeBase64(builder.sizedByteArray());
	}

	/**
	 * Upload path.
	 *
	 * @param path
	 *            the path
	 * @param name
	 *            the name
	 * @param keywords
	 *            the keywords
	 * @param metadata
	 *            the metadata
	 * @return the object
	 * @throws Exception
	 *             the exception
	 */
	public Object uploadPath(String path, String name, String keywords, String metadata) throws Exception {
		// initialize the datahash byte array entity object.
		DataHashByteArrayEntity dataHashByteArrayEntity = new DataHashByteArrayEntity();

		dataHashByteArrayEntity.setFile(path.getBytes());
		if (name == null || (name != null && name.equals(""))) {
			dataHashByteArrayEntity.setName(Math.abs(System.currentTimeMillis()) + "");
		} else {
			dataHashByteArrayEntity.setName(name);
		}

		String contentType = "Directory";
		dataHashByteArrayEntity.setContentType(contentType);
		dataHashByteArrayEntity.setKeywords(keywords);
		dataHashByteArrayEntity.setMetadata((metadata == null) ? null : JsonUtils.fromJson(metadata, Map.class));

		// Expose/load the file.
		PublishResult spfsBlockResult = exposeAndPinPath(path);

		String multiHashString = "";

		Iterator<MerkleNode> merkleNodeIter = spfsBlockResult.getMerkleNode().iterator();

		// log it.
		spfsBlockResult.getMerkleNode().stream().forEach(n -> {
			Logger.error(n);
		});

		while (merkleNodeIter.hasNext()) {
			MerkleNode merkleNode = (MerkleNode) merkleNodeIter.next();
			String namePath = "/" + merkleNode.name.get();
			if (namePath.equals(path)) {

				multiHashString = merkleNode.hash.toBase58();
				break;
			}
		}

		if (multiHashString == null || multiHashString.equals("")) {

			multiHashString = spfsBlockResult.getMerkleNode().get(spfsBlockResult.getMerkleNode().size() - 1).hash
					.toBase58();
		}

		// Serialize
		FlatBufferBuilder builder = new FlatBufferBuilder(1024);
		MessageDigest messageDigest = MessageDigest.getInstance("SHA-256");

		int digest = builder.createString(new String(
				org.bouncycastle.util.encoders.Hex.encode(messageDigest.digest(dataHashByteArrayEntity.getFile()))));

		int hash = builder.createString(multiHashString);
		int keywordsRes = builder.createString(
				(dataHashByteArrayEntity.getKeywords() == null) ? "" : dataHashByteArrayEntity.getKeywords());
		int metadataRes = builder.createString(JsonUtils
				.toJson((dataHashByteArrayEntity.getMetadata() == null) ? "" : dataHashByteArrayEntity.getMetadata()));
		int nameint = builder.createString(dataHashByteArrayEntity.getName());
		int type = builder.createString(dataHashByteArrayEntity.getContentType());

		ResourceHashMessage.startResourceHashMessage(builder);
		ResourceHashMessage.addDigest(builder, digest);
		ResourceHashMessage.addHash(builder, hash);
		ResourceHashMessage.addKeywords(builder, keywordsRes);
		ResourceHashMessage.addMetaData(builder, metadataRes);
		ResourceHashMessage.addName(builder, nameint);
		ResourceHashMessage.addTimestamp(builder, System.currentTimeMillis());
		ResourceHashMessage.addType(builder, type);
		builder.finish(ResourceHashMessage.endResourceHashMessage(builder));

		// return base64 encoded bytearray.
		return Base64.encodeBase64(builder.sizedByteArray());
	}

	/**
	 * Expose and pin binary.
	 *
	 * @param name
	 *            the name
	 * @param binary
	 *            the binary
	 * @return the publish result
	 * @throws IOException
	 *             Signals that an I/O exception has occurred.
	 * @throws ApiException
	 *             the api exception
	 */
	private PublishResult exposeAndPinBinary(String name, byte[] binary) throws IOException, ApiException {
		PublishResult result = new PublishResult();
		NamedStreamable.ByteArrayWrapper byteArrayWrapper = new NamedStreamable.ByteArrayWrapper(name, binary);
		List<MerkleNode> node = proximaxIfpsConnection.add(byteArrayWrapper);
		List<Multihash> pinned = proximaxIfpsConnection.pin.add(node.get(0).hash);
		result.setMerkleNode(node);
		result.setMultiHash(pinned);
		return result;
	}

	/**
	 * Expose and pin path.
	 *
	 * @param path
	 *            the path
	 * @return the publish result
	 * @throws Exception
	 *             the exception
	 */
	public PublishResult exposeAndPinPath(String path) throws Exception {
		PublishResult result = new PublishResult();
		try {
			List<NamedStreamable> streamables = new ArrayList<NamedStreamable>();
			NamedStreamable.FileWrapper fileWrapper = new NamedStreamable.FileWrapper(new File(path));
			streamables
					.add(new NamedStreamable.DirWrapper(new File(path).getAbsolutePath(), fileWrapper.getChildren()));
			// recursePathToBeAdded(streamables, path);
			List<MerkleNode> merkleNode = proximaxIfpsConnection.add(streamables, true, false);
			result.setMerkleNode(merkleNode);
		} catch (Exception e) {
			Logger.error("Error on decoding NEM Transaction Message." + e.getMessage());
		}
		return result;

	}

	/**
	 * Recurse path to be added.
	 *
	 * @param streamables
	 *            the streamables
	 * @param path
	 *            the path
	 */
	private void recursePathToBeAdded(List<NamedStreamable> streamables, String path) {
		File folder = new File(path);
		File[] listOfFiles = folder.listFiles();
		for (File file : listOfFiles) {
			if (file.isDirectory()) {
				NamedStreamable.FileWrapper fileWrapper = new NamedStreamable.FileWrapper(file);
				streamables.add(new NamedStreamable.DirWrapper(file.getAbsolutePath(), fileWrapper.getChildren()));
				recursePathToBeAdded(streamables, file.getAbsolutePath());
			} else {
				streamables.add(new NamedStreamable.FileWrapper(file));
			}
		}
	}

	/**
	 * Expose binary.
	 *
	 * @param name
	 *            the name
	 * @param binary
	 *            the binary
	 * @return the publish result
	 * @throws IOException
	 *             Signals that an I/O exception has occurred.
	 * @throws ApiException
	 *             the api exception
	 */
	private PublishResult exposeBinary(String name, byte[] binary) throws IOException, ApiException {
		PublishResult result = new PublishResult();
		NamedStreamable.ByteArrayWrapper byteArrayWrapper = new NamedStreamable.ByteArrayWrapper(name, binary);
		List<MerkleNode> node = proximaxIfpsConnection.add(byteArrayWrapper);
		result.setMerkleNode(node);
		return result;
	}

	/**
	 * Gets the binary hash only.
	 *
	 * @param name
	 *            the name
	 * @param binary
	 *            the binary
	 * @return the binary hash only
	 * @throws IOException
	 *             Signals that an I/O exception has occurred.
	 * @throws ApiException
	 *             the api exception
	 */
	private PublishResult getBinaryHashOnly(String name, byte[] binary) throws IOException, ApiException {
		PublishResult result = null;

		// store it in ipfs
		result = new PublishResult();
		NamedStreamable.ByteArrayWrapper byteArrayWrapper = new NamedStreamable.ByteArrayWrapper(name, binary);
		List<MerkleNode> node = proximaxIfpsConnection.add(byteArrayWrapper, false, true);
		result.setMerkleNode(node);

		return result;
	}

	/**
	 * Grab dirs.
	 *
	 * @param path
	 *            the path
	 * @param node
	 *            the node
	 * @throws IOException
	 *             Signals that an I/O exception has occurred.
	 * @throws ApiException
	 *             the api exception
	 */
	private void grabDirs(String path, List<MerkleNode> node) throws IOException, ApiException {
		File[] directories = new File(path).listFiles(File::isDirectory);
		for (File f : directories) {
			NamedStreamable.FileWrapper fileWrapper = new NamedStreamable.FileWrapper(f);
			NamedStreamable.DirWrapper dirWrapper = new NamedStreamable.DirWrapper(f.getName().toString(),
					fileWrapper.getChildren());
			node.addAll(proximaxIfpsConnection.add(dirWrapper, true, false));
			grabDirs(f.getAbsolutePath(), node);
		}
	}

}
